{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/lib/stripe.ts"],"sourcesContent":["import Stripe from \"stripe\";\n\nexport function getStripe(): Stripe {\n  const key = process.env.STRIPE_SECRET_KEY;\n  if (!key) {\n    throw new Error(\"STRIPE_SECRET_KEY is not set\");\n  }\n  return new Stripe(key, {\n    apiVersion: \"2024-04-10\",\n  });\n}\n\nexport const STRIPE_PRICES = {\n  BASIC: process.env.STRIPE_PRICE_BASIC,\n  PREMIUM: process.env.STRIPE_PRICE_PREMIUM,\n} as const;\n\nexport type PlanKey = keyof typeof STRIPE_PRICES;\n"],"names":[],"mappings":";;;;;;;AAEO,SAAS;IACd,MAAM,MAAM,QAAQ,GAAG,CAAC,iBAAiB;IACzC,IAAI,CAAC,KAAK;QACR,MAAM,IAAI,MAAM;IAClB;IACA,OAAO,IAAI,wJAAA,CAAA,UAAM,CAAC,KAAK;QACrB,YAAY;IACd;AACF;AAEO,MAAM,gBAAgB;IAC3B,OAAO,QAAQ,GAAG,CAAC,kBAAkB;IACrC,SAAS,QAAQ,GAAG,CAAC,oBAAoB;AAC3C"}},
    {"offset": {"line": 25, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 30, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient();\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;"],"names":[],"mappings":";;;;;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,uDAAA,CAAA,eAAY;AAEhE,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 44, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/lib/auth.ts"],"sourcesContent":["import { DefaultSession, NextAuthOptions, Session } from \"next-auth\";\nimport CredentialsProvider from \"next-auth/providers/credentials\";\nimport { PrismaAdapter } from \"@auth/prisma-adapter\";\nimport { prisma } from \"@/lib/prisma\";\nimport bcrypt from \"bcryptjs\";\n\nexport const authOptions: NextAuthOptions = {\n  adapter: PrismaAdapter(prisma) as any,\n  session: {\n    strategy: \"jwt\",\n  },\n  providers: [\n    CredentialsProvider({\n      name: \"credentials\",\n      credentials: {\n        email: { label: \"Email\", type: \"email\" },\n        password: { label: \"Password\", type: \"password\" },\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) {\n          return null;\n        }\n\n        const user = await prisma.user.findUnique({\n          where: {\n            email: credentials.email,\n          },\n        });\n\n        if (!user || !user.passwordHash) {\n          return null;\n        }\n\n        const isPasswordValid = await bcrypt.compare(\n          credentials.password,\n          user.passwordHash\n        );\n\n        if (!isPasswordValid) {\n          return null;\n        }\n\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          image: user.image || undefined,\n          role: user.role,\n        };\n      },\n    }),\n  ],\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user.id;\n        token.role = user.role;\n        // Make sure we have all required fields\n        if (!token.id || !token.role) {\n          console.error('Missing required token fields:', { token, user });\n        }\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      if (!session.user) {\n        console.error('No user in session object');\n        return session;\n      }\n\n      // Ensure we have all required fields from token\n      if (!token.id || !token.role) {\n        console.error('Missing required token fields:', { \n          tokenId: !!token.id,\n          tokenRole: !!token.role,\n          tokenKeys: Object.keys(token)\n        });\n        return session;\n      }\n\n      // Create a new session object with the correct type\n      const updatedSession = {\n        ...session,\n        user: {\n          ...session.user,\n          id: token.id as string,\n          role: token.role as string\n        }\n      };\n      \n      try {\n        // Fetch the latest user data with org\n        const dbUser = await prisma.user.findUnique({\n          where: { id: token.id as string },\n          include: { \n            org: {\n              select: { \n                id: true,\n                name: true \n              }\n            } \n          }\n        });\n        \n        if (dbUser) {\n          // Ensure we have a valid role\n          const userRole = dbUser.role || 'USER';\n          \n          // Update the session user with all required fields\n          updatedSession.user = {\n            ...updatedSession.user,\n            id: dbUser.id,\n            email: dbUser.email || null,\n            name: dbUser.name || null,\n            role: userRole,\n            orgId: dbUser.org?.id || null,\n            orgName: dbUser.org?.name || null\n          };\n          \n          // Add role to token for future requests\n          token.role = userRole;\n        } else {\n          console.error('User not found in database:', token.id);\n        }\n      } catch (error) {\n        console.error('Error fetching user data in session callback:', error);\n        // Return the session with token data if DB fetch fails\n      }\n      \n      return updatedSession;\n    },\n  },\n  pages: {\n    signIn: \"/login\",\n  },\n};"],"names":[],"mappings":"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"}},
    {"offset": {"line": 182, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 187, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/app/api/stripe/create-checkout-session/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport { getStripe, STRIPE_PRICES, PlanKey } from \"@/lib/stripe\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { getServerSession } from \"next-auth\";\r\nimport { authOptions } from \"@/lib/auth\";\r\n\r\nexport async function POST(req: NextRequest) {\r\n  try {\r\n    const { plan, orgId } = (await req.json()) as {\r\n      plan: PlanKey;\r\n      orgId?: string;\r\n    };\r\n    if (!plan || !(plan in STRIPE_PRICES)) {\r\n      return NextResponse.json({ error: \"Invalid plan\" }, { status: 400 });\r\n    }\r\n\r\n    // Debug logs to help diagnose env issues (visible only on server)\r\n    console.log(\"[Stripe] Requested plan:\", plan);\r\n    console.log(\"[Stripe] STRIPE_PRICES map:\", {\r\n      BASIC: !!STRIPE_PRICES.BASIC ? \"set\" : \"missing\",\r\n      PREMIUM: !!STRIPE_PRICES.PREMIUM ? \"set\" : \"missing\",\r\n    });\r\n\r\n    const priceId = STRIPE_PRICES[plan];\r\n    if (!priceId) {\r\n      return NextResponse.json(\r\n        {\r\n          error: \"Price not configured\",\r\n          hint:\r\n            process.env.NODE_ENV !== \"production\"\r\n              ? `Missing env for ${plan}. Set STRIPE_PRICE_${plan} in .env.local and restart the server.`\r\n              : undefined,\r\n        },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    const session = await getServerSession(authOptions);\r\n    const userEmail = session?.user?.email ?? undefined;\r\n    const userId = session?.user?.id ?? undefined;\r\n\r\n    let resolvedOrgId = orgId;\r\n    if (!resolvedOrgId && userId) {\r\n      const user = await prisma.user.findUnique({\r\n        where: { id: userId },\r\n        select: { orgId: true },\r\n      });\r\n      resolvedOrgId = user?.orgId ?? undefined;\r\n    }\r\n\r\n    const stripe = getStripe();\r\n\r\n    const checkout = await stripe.checkout.sessions.create({\r\n      mode: \"subscription\",\r\n      payment_method_types: [\"card\"],\r\n      customer_email: userEmail,\r\n      line_items: [\r\n        {\r\n          price: priceId,\r\n          quantity: 1,\r\n        },\r\n      ],\r\n      allow_promotion_codes: true,\r\n      subscription_data: {\r\n        metadata: {\r\n          orgId: resolvedOrgId ?? \"\",\r\n          userId: userId ?? \"\",\r\n          plan,\r\n        },\r\n      },\r\n      metadata: {\r\n        orgId: resolvedOrgId ?? \"\",\r\n        userId: userId ?? \"\",\r\n        plan,\r\n      },\r\n      success_url: `${req.nextUrl.origin}/success?session_id={CHECKOUT_SESSION_ID}`,\r\n      cancel_url: `${req.nextUrl.origin}/cancel`,\r\n    });\r\n\r\n    return NextResponse.json({ url: checkout.url }, { status: 200 });\r\n  } catch (err) {\r\n    console.error(\"create-checkout-session error\", err);\r\n    return NextResponse.json({ error: \"Internal error\" }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAMO,eAAe,KAAK,GAAgB;IACzC,IAAI;QACF,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAI,MAAM,IAAI,IAAI;QAIvC,IAAI,CAAC,QAAQ,CAAC,CAAC,QAAQ,+GAAA,CAAA,gBAAa,GAAG;YACrC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpE;QAEA,kEAAkE;QAClE,QAAQ,GAAG,CAAC,4BAA4B;QACxC,QAAQ,GAAG,CAAC,+BAA+B;YACzC,OAAO,CAAC,CAAC,+GAAA,CAAA,gBAAa,CAAC,KAAK,GAAG,QAAQ;YACvC,SAAS,CAAC,CAAC,+GAAA,CAAA,gBAAa,CAAC,OAAO,GAAG,QAAQ;QAC7C;QAEA,MAAM,UAAU,+GAAA,CAAA,gBAAa,CAAC,KAAK;QACnC,IAAI,CAAC,SAAS;YACZ,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBACE,OAAO;gBACP,MACE,uCACI,CAAC,gBAAgB,EAAE,KAAK,mBAAmB,EAAE,KAAK,sCAAsC,CAAC;YAEjG,GACA;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,UAAU,MAAM,CAAA,GAAA,uIAAA,CAAA,mBAAgB,AAAD,EAAE,6GAAA,CAAA,cAAW;QAClD,MAAM,YAAY,SAAS,MAAM,SAAS;QAC1C,MAAM,SAAS,SAAS,MAAM,MAAM;QAEpC,IAAI,gBAAgB;QACpB,IAAI,CAAC,iBAAiB,QAAQ;YAC5B,MAAM,OAAO,MAAM,+GAAA,CAAA,SAAM,CAAC,IAAI,CAAC,UAAU,CAAC;gBACxC,OAAO;oBAAE,IAAI;gBAAO;gBACpB,QAAQ;oBAAE,OAAO;gBAAK;YACxB;YACA,gBAAgB,MAAM,SAAS;QACjC;QAEA,MAAM,SAAS,CAAA,GAAA,+GAAA,CAAA,YAAS,AAAD;QAEvB,MAAM,WAAW,MAAM,OAAO,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC;YACrD,MAAM;YACN,sBAAsB;gBAAC;aAAO;YAC9B,gBAAgB;YAChB,YAAY;gBACV;oBACE,OAAO;oBACP,UAAU;gBACZ;aACD;YACD,uBAAuB;YACvB,mBAAmB;gBACjB,UAAU;oBACR,OAAO,iBAAiB;oBACxB,QAAQ,UAAU;oBAClB;gBACF;YACF;YACA,UAAU;gBACR,OAAO,iBAAiB;gBACxB,QAAQ,UAAU;gBAClB;YACF;YACA,aAAa,CAAC,EAAE,IAAI,OAAO,CAAC,MAAM,CAAC,yCAAyC,CAAC;YAC7E,YAAY,CAAC,EAAE,IAAI,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC;QAC5C;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,KAAK,SAAS,GAAG;QAAC,GAAG;YAAE,QAAQ;QAAI;IAChE,EAAE,OAAO,KAAK;QACZ,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAiB,GAAG;YAAE,QAAQ;QAAI;IACtE;AACF"}},
    {"offset": {"line": 284, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}