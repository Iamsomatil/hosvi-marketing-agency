{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient();\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;"],"names":[],"mappings":";;;;;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,uDAAA,CAAA,eAAY;AAEhE,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 14, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/lib/auth.ts"],"sourcesContent":["import { DefaultSession, NextAuthOptions, Session } from \"next-auth\";\nimport CredentialsProvider from \"next-auth/providers/credentials\";\nimport { PrismaAdapter } from \"@auth/prisma-adapter\";\nimport { prisma } from \"@/lib/prisma\";\nimport bcrypt from \"bcryptjs\";\n\nexport const authOptions: NextAuthOptions = {\n  adapter: PrismaAdapter(prisma) as any,\n  session: {\n    strategy: \"jwt\",\n  },\n  providers: [\n    CredentialsProvider({\n      name: \"credentials\",\n      credentials: {\n        email: { label: \"Email\", type: \"email\" },\n        password: { label: \"Password\", type: \"password\" },\n      },\n      async authorize(credentials) {\n        if (!credentials?.email || !credentials?.password) {\n          return null;\n        }\n\n        const user = await prisma.user.findUnique({\n          where: {\n            email: credentials.email,\n          },\n        });\n\n        if (!user || !user.passwordHash) {\n          return null;\n        }\n\n        const isPasswordValid = await bcrypt.compare(\n          credentials.password,\n          user.passwordHash\n        );\n\n        if (!isPasswordValid) {\n          return null;\n        }\n\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n          image: user.image || undefined,\n          role: user.role,\n        };\n      },\n    }),\n  ],\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user.id;\n        token.role = user.role;\n        // Make sure we have all required fields\n        if (!token.id || !token.role) {\n          console.error('Missing required token fields:', { token, user });\n        }\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      if (!session.user) {\n        console.error('No user in session object');\n        return session;\n      }\n\n      // Ensure we have all required fields from token\n      if (!token.id || !token.role) {\n        console.error('Missing required token fields:', { \n          tokenId: !!token.id,\n          tokenRole: !!token.role,\n          tokenKeys: Object.keys(token)\n        });\n        return session;\n      }\n\n      // Create a new session object with the correct type\n      const updatedSession = {\n        ...session,\n        user: {\n          ...session.user,\n          id: token.id as string,\n          role: token.role as string\n        }\n      };\n      \n      try {\n        // Fetch the latest user data with org\n        const dbUser = await prisma.user.findUnique({\n          where: { id: token.id as string },\n          include: { \n            org: {\n              select: { \n                id: true,\n                name: true \n              }\n            } \n          }\n        });\n        \n        if (dbUser) {\n          // Ensure we have a valid role\n          const userRole = dbUser.role || 'USER';\n          \n          // Update the session user with all required fields\n          updatedSession.user = {\n            ...updatedSession.user,\n            id: dbUser.id,\n            email: dbUser.email || null,\n            name: dbUser.name || null,\n            role: userRole,\n            orgId: dbUser.org?.id || null,\n            orgName: dbUser.org?.name || null\n          };\n          \n          // Add role to token for future requests\n          token.role = userRole;\n        } else {\n          console.error('User not found in database:', token.id);\n        }\n      } catch (error) {\n        console.error('Error fetching user data in session callback:', error);\n        // Return the session with token data if DB fetch fails\n      }\n      \n      return updatedSession;\n    },\n  },\n  pages: {\n    signIn: \"/login\",\n  },\n};"],"names":[],"mappings":"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"}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 162, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/app/api/auth/[...nextauth]/route.ts"],"sourcesContent":["import NextAuth from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\n\nconst handler = NextAuth(authOptions) as any;\n\nexport { handler as GET, handler as POST };"],"names":[],"mappings":";;;;;;;;;AAGA,MAAM,UAAU,CAAA,GAAA,uIAAA,CAAA,UAAQ,AAAD,EAAE,6GAAA,CAAA,cAAW"}},
    {"offset": {"line": 173, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}